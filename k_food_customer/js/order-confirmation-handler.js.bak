// Order Confirmation Modal Handler
const OrderConfirmationHandler = {
  // Properties
  socketReady: false,
  socketQueue: [],
  modal: null,
  socket: null,
  modalPromiseResolve: null,
  modalPromiseReject: null,  
  currentOrderPromise: null,
  orderTimeout: null,
  currentOrderData: null,

  // Initialization
  init() {
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", () => this._initialize());
    } else {
      this._initialize();
    }
  },

  _initialize() {
    this.modal = document.getElementById("orderConfirmationModal");
    if (!this.modal) {
      console.error("Modal element not found");
      return;
    }

      init() {  init: function() {  init: function() {

    this.initWebSocket();

    this.attachEventListeners();    if (document.readyState === "loading") {    if (document.readyState === "loading") {    if (document.readyState === "loading") {

    

    window.addEventListener("beforeunload", () => {      document.addEventListener("DOMContentLoaded", () => this._initialize());      document.addEventListener("DOMContentLoaded", () => this._initialize());      document.addEventListener("DOMContentLoaded", () => this._initialize());

      if (this.socket) {

        this.socket.close();    } else {    } else {    } else {

      }

    });      this._initialize();      this._initialize();      this._initialize();

  },

    }    }    }

  // Event Listeners

  attachEventListeners() {  },  },  },

    const modalContent = this.modal.querySelector(".modal-content");

    if (modalContent) {  _initialize: function() {  _initialize: function() {

      modalContent.addEventListener("click", (e) => e.stopPropagation());

    }  _initialize() {    this.modal = document.getElementById("orderConfirmationModal");    this.modal = document.getElementById("orderConfirmationModal");



    this.modal.addEventListener("click", (e) => {    this.modal = document.getElementById("orderConfirmationModal");    if (!this.modal) {    if (!this.modal) {

      if (e.target === this.modal) {

        this.hide();    if (!this.modal) {      console.error("Modal element not found");      console.error("Modal element not found");

      }

    });      console.error("Modal element not found");      return;      return;



    const confirmBtn = this.modal.querySelector(".btn-confirm");      return;        

    const cancelBtn = this.modal.querySelector(".btn-cancel");

    const closeBtn = this.modal.querySelector(".modal-close");    }    this.initWebSocket();    // Initialize WebSocket and attach event listeners



    if (confirmBtn) {        this.attachEventListeners();    this.initWebSocket();

      confirmBtn.addEventListener("click", () => this.processOrder());

    }    this.initWebSocket();        this.attachEventListeners();



    [cancelBtn, closeBtn].forEach(btn => {    this.attachEventListeners();    window.addEventListener("beforeunload", () => {    

      if (btn) {

        btn.addEventListener("click", () => this.hide());          if (this.socket) {    // Clean up on page unload

      }

    });    window.addEventListener("beforeunload", () => {        this.socket.close();    window.addEventListener("beforeunload", () => {

  },

      if (this.socket) {      }      if (this.socket) {

  // Modal Management

  show() {        this.socket.close();    });        this.socket.close();

    return new Promise((resolve, reject) => {

      try {      }  },      }

        if (!this.modal) {

          throw new Error("Modal not initialized");    });    });

        }

  },  // Event Listeners  },

        this.modalPromiseResolve = resolve;

        this.modalPromiseReject = reject;  attachEventListeners: function() {



        this.modal.style.display = "block";  // Event Listeners    const modalContent = this.modal.querySelector(".modal-content");  // WebSocket Management

        setTimeout(() => {

          this.modal.classList.add("show");  attachEventListeners() {    if (modalContent) {  initWebSocket: function() {

        }, 10);

    const modalContent = this.modal.querySelector(".modal-content");      modalContent.addEventListener("click", (e) => e.stopPropagation());    const wsProtocol = window.location.protocol === "https:" ? "wss:" : "ws:";

      } catch (error) {

        console.error("Error showing modal:", error);    if (modalContent) {    }    const wsUrl = `${wsProtocol}//${window.location.host}/websocket`;

        reject(error);

      }      modalContent.addEventListener("click", (e) => e.stopPropagation());    

    });

  },    }    this.modal.addEventListener("click", (e) => {    this.socket = new WebSocket(wsUrl);



  hide() {      if (e.target === this.modal) {    

    if (!this.modal) return;

    this.modal.addEventListener("click", (e) => {        this.hide();    this.socket.onopen = () => {

    this.modal.classList.remove("show");

    setTimeout(() => {      if (e.target === this.modal) {      }      console.log("WebSocket connection established");

      this.modal.style.display = "none";

    }, 300);        this.hide();    });      this.socketReady = true;



    if (this.modalPromiseReject) {      }  },      while (this.socketQueue.length > 0) {

      this.modalPromiseReject(new Error("Modal closed"));

    }    });        const message = this.socketQueue.shift();



    this.modalPromiseResolve = null;  // Modal Management        this.socket.send(JSON.stringify(message));

    this.modalPromiseReject = null;

  },    const confirmBtn = this.modal.querySelector(".btn-confirm");  show: function() {      }



  // WebSocket Management    const cancelBtn = this.modal.querySelector(".btn-cancel");    return new Promise((resolve, reject) => {    };

  initWebSocket() {

    const wsProtocol = window.location.protocol === "https:" ? "wss:" : "ws:";    const closeBtn = this.modal.querySelector(".modal-close");      try {    

    const wsUrl = `${wsProtocol}//${window.location.host}/websocket`;

            if (!this.modal) {    this.socket.onclose = () => {

    this.socket = new WebSocket(wsUrl);

        if (confirmBtn) {          throw new Error("Modal not initialized");      console.log("WebSocket connection closed");

    this.socket.onopen = () => {

      console.log("WebSocket connection established");      confirmBtn.addEventListener("click", () => this.processOrder());        }      this.socketReady = false;

      this.socketReady = true;

      while (this.socketQueue.length > 0) {    }      setTimeout(() => this.initWebSocket(), 5000);

        const message = this.socketQueue.shift();

        this.socket.send(JSON.stringify(message));        this.modalPromiseResolve = resolve;    };

      }

    };    [cancelBtn, closeBtn].forEach(btn => {        this.modalPromiseReject = reject;    

    

    this.socket.onclose = () => {      if (btn) {    this.socket.onerror = (error) => {

      console.log("WebSocket connection closed");

      this.socketReady = false;        btn.addEventListener("click", () => this.hide());        this.modal.style.display = "block";      console.error("WebSocket error:", error);

      setTimeout(() => this.initWebSocket(), 5000);

    };      }        setTimeout(() => {      this.socketReady = false;

    

    this.socket.onerror = (error) => {    });          this.modal.classList.add("show");    };

      console.error("WebSocket error:", error);

      this.socketReady = false;  },        }, 10);    

    };

        this.socket.onmessage = (event) => {

    this.socket.onmessage = (event) => {

      try {  // Modal Management        const confirmBtn = this.modal.querySelector(".btn-confirm");      try {

        const message = JSON.parse(event.data);

        this.handleWebSocketMessage(message);  show() {        const cancelBtn = this.modal.querySelector(".btn-cancel");        const message = JSON.parse(event.data);

      } catch (error) {

        console.error("Error processing WebSocket message:", error);    return new Promise((resolve, reject) => {        const closeBtn = this.modal.querySelector(".modal-close");        this.handleWebSocketMessage(message);

      }

    };      try {      } catch (error) {

  },

        if (!this.modal) {        if (confirmBtn) {        console.error("Error processing WebSocket message:", error);

  handleWebSocketMessage(message) {

    switch (message.type) {          throw new Error("Modal not initialized");          confirmBtn.onclick = () => {      }

      case "order_status":

        this.handleOrderStatusUpdate(message.data);        }            this.hide();    };

        break;

      case "order_confirmation":            resolve(true);  },

        this.handleOrderConfirmation(message.data);

        break;        this.modalPromiseResolve = resolve;          };

      default:

        console.warn("Unknown message type:", message.type);        this.modalPromiseReject = reject;        }  handleWebSocketMessage: function(message) {

    }

  },    switch (message.type) {



  handleOrderStatusUpdate(data) {        this.modal.style.display = "block";        if (cancelBtn) {      case "order_status":

    const statusElement = document.querySelector(".order-status");

    if (statusElement) {        setTimeout(() => {          cancelBtn.onclick = () => {        this.handleOrderStatusUpdate(message.data);

      statusElement.textContent = data.status;

      statusElement.className = `order-status ${data.status.toLowerCase()}`;          this.modal.classList.add("show");            this.hide();        break;

    }

  },        }, 10);            resolve(false);      case "order_confirmation":



  handleOrderConfirmation(data) {          };        this.handleOrderConfirmation(message.data);

    if (this.currentOrderPromise) {

      if (data.success) {      } catch (error) {        }        break;

        this.currentOrderPromise.resolve(data);

      } else {        console.error("Error showing modal:", error);      default:

        this.currentOrderPromise.reject(new Error(data.message || "Order processing failed"));

      }        reject(error);        if (closeBtn) {        console.warn("Unknown message type:", message.type);

      this.currentOrderPromise = null;

            }          closeBtn.onclick = () => {    }

      if (this.orderTimeout) {

        clearTimeout(this.orderTimeout);    });            this.hide();  },

        this.orderTimeout = null;

      }  },            resolve(false);

    }

  },          };  handleOrderStatusUpdate: function(data) {



  // Content Management  hide() {        }    const statusElement = document.querySelector(".order-status");

  updateModalContent(data) {

    try {    if (!this.modal) return;    if (statusElement) {

      if (!this.modal || !this.validateOrderData(data)) {

        throw new Error("Invalid modal or order data");      } catch (error) {      statusElement.textContent = data.status;

      }

    this.modal.classList.remove("show");        console.error("Error showing modal:", error);      statusElement.className = `order-status ${data.status.toLowerCase()}`;

      const sections = {

        items: this.getOrCreateContainer("order-items"),    setTimeout(() => {        reject(error);    }

        customerInfo: this.getOrCreateContainer("customer-info"),

        payment: this.getOrCreateContainer("payment-info"),      this.modal.style.display = "none";      }  },

        summary: this.getOrCreateContainer("order-summary")

      };    }, 300);  },  handleOrderConfirmation: function(data) {



      Object.entries(sections).forEach(([section, container]) => {    if (this.currentOrderPromise) {

        try {

          switch (section) {    if (this.modalPromiseReject) {  hide: function() {      if (data.success) {

            case "items":

              container.innerHTML = this.generateItemsList(data.items);      this.modalPromiseReject(new Error("Modal closed"));    if (!this.modal) return;        this.currentOrderPromise.resolve(data);

              break;

            case "customerInfo":    }      } else {

              container.innerHTML = this.generateCustomerInfo(data.customerInfo);

              break;    this.modal.classList.remove("show");        this.currentOrderPromise.reject(new Error(data.message || "Order processing failed"));

            case "payment":

              container.innerHTML = this.generatePaymentInfo(data.payment);    this.modalPromiseResolve = null;      }

              break;

            case "summary":    this.modalPromiseReject = null;    const confirmBtn = this.modal.querySelector(".btn-confirm");      this.currentOrderPromise = null;

              container.innerHTML = this.generateOrderSummary(data);

              break;  },    const cancelBtn = this.modal.querySelector(".btn-cancel");      

          }

        } catch (sectionError) {    const closeBtn = this.modal.querySelector(".modal-close");      if (this.orderTimeout) {

          console.error(`Error updating ${section}:`, sectionError);

          container.innerHTML = `<div class="error-message">Error loading ${section}</div>`;  // WebSocket Management        clearTimeout(this.orderTimeout);

        }

      });  initWebSocket() {    if (confirmBtn) confirmBtn.onclick = null;        this.orderTimeout = null;

    } catch (error) {

      console.error("Error updating modal content:", error);    const wsProtocol = window.location.protocol === "https:" ? "wss:" : "ws:";    if (cancelBtn) cancelBtn.onclick = null;      }

      throw error;

    }    const wsUrl = `${wsProtocol}//${window.location.host}/websocket`;    if (closeBtn) closeBtn.onclick = null;    }

  },

      },

  validateOrderData(data) {

    if (!data || typeof data !== "object") {    this.socket = new WebSocket(wsUrl);    setTimeout(() => {  // Event Listeners

      return false;

    }          this.modal.style.display = "none";  attachEventListeners: function() {



    const requiredSections = ["customerInfo", "payment", "items", "amounts"];    this.socket.onopen = () => {    }, 300);    const modalContent = this.modal.querySelector(".modal-content");

    for (const section of requiredSections) {

      if (!data[section] || typeof data[section] !== "object") {      console.log("WebSocket connection established");    if (modalContent) {

        return false;

      }      this.socketReady = true;    this.modalPromiseResolve = null;      modalContent.addEventListener("click", (e) => e.stopPropagation());

    }

      while (this.socketQueue.length > 0) {    this.modalPromiseReject = null;    }

    if (!Array.isArray(data.items) || data.items.length === 0) {

      return false;        const message = this.socketQueue.shift();    // Click outside modal to close

    }

        this.socket.send(JSON.stringify(message));  // WebSocket Management    this.modal.addEventListener("click", (e) => {

    return true;

  },      }  initWebSocket: function() {      if (e.target === this.modal) {



  getOrCreateContainer(id) {    };    const wsProtocol = window.location.protocol === "https:" ? "wss:" : "ws:";        this.hide();

    let container = document.getElementById(`modal-${id}`);

    if (!container) {        const wsUrl = `${wsProtocol}//${window.location.host}/websocket`;      }

      container = document.createElement("div");

      container.id = `modal-${id}`;    this.socket.onclose = () => {        });

      container.className = "modal-section";

      this.modal.querySelector(".modal-content").appendChild(container);      console.log("WebSocket connection closed");    this.socket = new WebSocket(wsUrl);  },

    }

    return container;      this.socketReady = false;    this.socket.onopen = () => {  updateModalContent: function(data) {

  },

      setTimeout(() => this.initWebSocket(), 5000);      console.log("WebSocket connection established");    try {

  // Content Generation

  generateItemsList(items) {    };      this.socketReady = true;      if (!this.modal || !this.validateOrderData(data)) {

    return `

      <div class="order-items">          while (this.socketQueue.length > 0) {        throw new Error("Invalid modal or order data");

        <h3>Order Items</h3>

        <ul class="items-list">    this.socket.onerror = (error) => {        const message = this.socketQueue.shift();      }

          ${items.map(item => `

            <li class="item">      console.error("WebSocket error:", error);        this.socket.send(JSON.stringify(message));

              <span class="item-name">${item.name}</span>

              <span class="item-quantity">x${item.quantity}</span>      this.socketReady = false;      }      // Get or create required containers

              <span class="item-price">₱${(item.price * item.quantity).toFixed(2)}</span>

            </li>    };    };      const sections = {

          `).join("")}

        </ul>                items: this.getOrCreateContainer("order-items"),

      </div>

    `;    this.socket.onmessage = (event) => {    this.socket.onclose = () => {        customerInfo: this.getOrCreateContainer("customer-info"),

  },

      try {      console.log("WebSocket connection closed");        payment: this.getOrCreateContainer("payment-info"),

  generateCustomerInfo(customerInfo) {

    return `        const message = JSON.parse(event.data);      this.socketReady = false;        summary: this.getOrCreateContainer("order-summary")

      <div class="customer-info">

        <h3>Customer Information</h3>        this.handleWebSocketMessage(message);      setTimeout(() => this.initWebSocket(), 5000);      };

        <p><strong>Name:</strong> ${customerInfo.name}</p>

        <p><strong>Phone:</strong> ${customerInfo.phone}</p>      } catch (error) {    };

        <p><strong>Email:</strong> ${customerInfo.email}</p>

        <p><strong>Address:</strong> ${customerInfo.address}</p>        console.error("Error processing WebSocket message:", error);          // Update each section with error handling

      </div>

    `;      }    this.socket.onerror = (error) => {      Object.entries(sections).forEach(([section, container]) => {

  },

    };      console.error("WebSocket error:", error);        try {

  generatePaymentInfo(payment) {

    return `  },      this.socketReady = false;          switch (section) {

      <div class="payment-info">

        <h3>Payment Information</h3>    };            case "items":

        <p><strong>Method:</strong> ${payment.method}</p>

        <p><strong>Status:</strong> <span class="payment-status ${payment.status.toLowerCase()}">${payment.status}</span></p>  handleWebSocketMessage(message) {                  container.innerHTML = this.generateItemsList(data.items);

        ${payment.reference ? `<p><strong>Reference:</strong> ${payment.reference}</p>` : ""}

      </div>    switch (message.type) {    this.socket.onmessage = (event) => {              break;

    `;

  },      case "order_status":      try {            case "customerInfo":



  generateOrderSummary(data) {        this.handleOrderStatusUpdate(message.data);        const message = JSON.parse(event.data);              container.innerHTML = this.generateCustomerInfo(data.customerInfo);

    const { amounts } = data;

    return `        break;        this.handleWebSocketMessage(message);              break;

      <div class="order-summary">

        <h3>Order Summary</h3>      case "order_confirmation":      } catch (error) {            case "payment":

        <div class="summary-row">

          <span>Subtotal:</span>        this.handleOrderConfirmation(message.data);        console.error("Error processing WebSocket message:", error);              container.innerHTML = this.generatePaymentInfo(data.payment);

          <span>₱${amounts.subtotal.toFixed(2)}</span>

        </div>        break;      }              break;

        ${amounts.discount ? `

        <div class="summary-row">      default:    };            case "summary":

          <span>Discount:</span>

          <span>-₱${amounts.discount.toFixed(2)}</span>        console.warn("Unknown message type:", message.type);  },              container.innerHTML = this.generateOrderSummary(data);

        </div>

        ` : ""}    }              break;

        <div class="summary-row">

          <span>Delivery Fee:</span>  },  handleWebSocketMessage: function(message) {          }

          <span>₱${amounts.deliveryFee.toFixed(2)}</span>

        </div>    switch (message.type) {        } catch (sectionError) {

        <div class="summary-row total">

          <span>Total:</span>  handleOrderStatusUpdate(data) {      case "order_status":          console.error(`Error updating ${section}:`, sectionError);

          <span>₱${amounts.total.toFixed(2)}</span>

        </div>    const statusElement = document.querySelector(".order-status");        this.handleOrderStatusUpdate(message.data);          container.innerHTML = `<div class="error-message">Error loading ${section}</div>`;

      </div>

    `;    if (statusElement) {        break;        }

  },

      statusElement.textContent = data.status;      case "order_confirmation":      });

  // Order Processing

  async processOrder() {      statusElement.className = `order-status ${data.status.toLowerCase()}`;        this.handleOrderConfirmation(message.data);    } catch (error) {

    try {

      const orderData = this.collectOrderData();    }        break;      console.error("Error updating modal content:", error);

      if (!orderData) {

        throw new Error("Failed to collect order data");  },      default:      throw error;

      }

        console.warn("Unknown message type:", message.type);    }

      await this.updateModalContent(orderData);

      const confirmed = await this.show();  handleOrderConfirmation(data) {    }  },



      if (!confirmed) {    if (this.currentOrderPromise) {  validateOrderData: function(data) {

        return { success: false, message: "Order cancelled by user" };

      }      if (data.success) {  handleOrderStatusUpdate: function(data) {    if (!data || typeof data !== "object") {



      if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {        this.currentOrderPromise.resolve(data);    const statusElement = document.querySelector(".order-status");      return false;

        throw new Error("WebSocket connection not available");

      }      } else {    if (statusElement) {    }



      return new Promise((resolve, reject) => {        this.currentOrderPromise.reject(new Error(data.message || "Order processing failed"));      statusElement.textContent = data.status;

        const orderMessage = {

          type: "new_order",      }      statusElement.className = `order-status ${data.status.toLowerCase()}`;    // Validate required data sections

          data: orderData

        };      this.currentOrderPromise = null;    }    const requiredSections = ["customerInfo", "payment", "items", "amounts"];



        this.socket.send(JSON.stringify(orderMessage));        },    for (const section of requiredSections) {

        this.currentOrderPromise = { resolve, reject };

      if (this.orderTimeout) {      if (!data[section] || typeof data[section] !== "object") {

        this.orderTimeout = setTimeout(() => {

          if (this.currentOrderPromise) {        clearTimeout(this.orderTimeout);  handleOrderConfirmation: function(data) {        return false;

            this.currentOrderPromise.reject(new Error("Order confirmation timeout"));

            this.currentOrderPromise = null;        this.orderTimeout = null;    if (this.currentOrderPromise) {      }

          }

        }, 30000);      }      if (data.success) {    }

      });

    }        this.currentOrderPromise.resolve(data);

    } catch (error) {

      console.error("Error processing order:", error);  },      } else {    // Validate items array

      throw error;

    }        this.currentOrderPromise.reject(new Error(data.message || "Order processing failed"));    if (!Array.isArray(data.items) || data.items.length === 0) {

  },

  // Content Management      }      return false;

  collectOrderData() {

    try {  updateModalContent(data) {      this.currentOrderPromise = null;    }

      const form = document.getElementById("orderForm");

      if (!form) {    try {      

        throw new Error("Order form not found");

      }      if (!this.modal || !this.validateOrderData(data)) {      if (this.orderTimeout) {    return true;



      const cartItems = Array.from(document.querySelectorAll(".cart-item")).map(item => ({        throw new Error("Invalid modal or order data");        clearTimeout(this.orderTimeout);  },

        id: item.dataset.itemId,

        name: item.querySelector(".item-name").textContent,      }        this.orderTimeout = null;

        quantity: parseInt(item.querySelector(".item-quantity").value, 10),

        price: parseFloat(item.querySelector(".item-price").dataset.price)      }  getOrCreateContainer: function(id) {

      }));

      const sections = {    }    let container = document.getElementById(`modal-${id}`);

      if (cartItems.length === 0) {

        throw new Error("Cart is empty");        items: this.getOrCreateContainer("order-items"),  },    if (!container) {

      }

        customerInfo: this.getOrCreateContainer("customer-info"),      container = document.createElement("div");

      const subtotal = cartItems.reduce((sum, item) => sum + (item.price * item.quantity), 0);

      const deliveryFee = 50;        payment: this.getOrCreateContainer("payment-info"),  // Content Management      container.id = `modal-${id}`;

      const discount = 0;

      const total = subtotal + deliveryFee - discount;        summary: this.getOrCreateContainer("order-summary")  updateModalContent: function(data) {      container.className = "modal-section";



      const customerInfo = {      };    try {      this.modal.querySelector(".modal-content").appendChild(container);

        name: form.querySelector('[name="customer_name"]').value,

        phone: form.querySelector('[name="phone"]').value,      if (!this.modal || !this.validateOrderData(data)) {    }

        email: form.querySelector('[name="email"]').value,

        address: form.querySelector('[name="address"]').value      Object.entries(sections).forEach(([section, container]) => {        throw new Error("Invalid modal or order data");    return container;

      };

        try {      const sections = {  generateItemsList: function(items) {

      const paymentMethod = form.querySelector('[name="payment_method"]:checked').value;

          switch (section) {        items: this.getOrCreateContainer("order-items"),    return `

      return {

        items: cartItems,            case "items":        customerInfo: this.getOrCreateContainer("customer-info"),      <div class="order-items">

        customerInfo,

        payment: {              container.innerHTML = this.generateItemsList(data.items);        payment: this.getOrCreateContainer("payment-info"),        <h3>Order Items</h3>

          method: paymentMethod,

          status: "Pending"              break;        summary: this.getOrCreateContainer("order-summary")        <ul class="items-list">

        },

        amounts: {            case "customerInfo":      };          ${items.map(item => `

          subtotal,

          deliveryFee,              container.innerHTML = this.generateCustomerInfo(data.customerInfo);            <li class="item">

          discount,

          total              break;      Object.entries(sections).forEach(([section, container]) => {              <span class="item-name">${item.name}</span>

        }

      };            case "payment":        try {              <span class="item-quantity">x${item.quantity}</span>

    } catch (error) {

      console.error("Error collecting order data:", error);              container.innerHTML = this.generatePaymentInfo(data.payment);          switch (section) {              <span class="item-price">₱${(item.price * item.quantity).toFixed(2)}</span>

      return null;

    }              break;            case "items":            </li>

  }

};            case "summary":              container.innerHTML = this.generateItemsList(data.items);          `).join("")}



// Initialize the handler              container.innerHTML = this.generateOrderSummary(data);              break;        </ul>

document.addEventListener("DOMContentLoaded", () => {

  OrderConfirmationHandler.init();              break;            case "customerInfo":      </div>

});
          }              container.innerHTML = this.generateCustomerInfo(data.customerInfo);    `;

        } catch (sectionError) {              break;  },

          console.error(`Error updating ${section}:`, sectionError);            case "payment":

          container.innerHTML = `<div class="error-message">Error loading ${section}</div>`;              container.innerHTML = this.generatePaymentInfo(data.payment);  generateCustomerInfo: function(customerInfo) {

        }              break;    return `

      });            case "summary":      <div class="customer-info">

    } catch (error) {              container.innerHTML = this.generateOrderSummary(data);        <h3>Customer Information</h3>

      console.error("Error updating modal content:", error);              break;        <p><strong>Name:</strong> ${customerInfo.name}</p>

      throw error;          }        <p><strong>Phone:</strong> ${customerInfo.phone}</p>

    }        } catch (sectionError) {        <p><strong>Email:</strong> ${customerInfo.email}</p>

  },          console.error(`Error updating ${section}:`, sectionError);        <p><strong>Address:</strong> ${customerInfo.address}</p>

          container.innerHTML = `<div class="error-message">Error loading ${section}</div>`;      </div>

  validateOrderData(data) {        }    `;

    if (!data || typeof data !== "object") {      });  },

      return false;    } catch (error) {

    }      console.error("Error updating modal content:", error);  generatePaymentInfo: function(payment) {

      throw error;    return `

    const requiredSections = ["customerInfo", "payment", "items", "amounts"];    }      <div class="payment-info">

    for (const section of requiredSections) {  },        <h3>Payment Information</h3>

      if (!data[section] || typeof data[section] !== "object") {        <p><strong>Method:</strong> ${payment.method}</p>

        return false;  validateOrderData: function(data) {        <p><strong>Status:</strong> <span class="payment-status ${payment.status.toLowerCase()}">${payment.status}</span></p>

      }    if (!data || typeof data !== "object") {        ${payment.reference ? `<p><strong>Reference:</strong> ${payment.reference}</p>` : ""}

    }      return false;      </div>

    }    `;

    if (!Array.isArray(data.items) || data.items.length === 0) {    const requiredSections = ["customerInfo", "payment", "items", "amounts"];

      return false;    for (const section of requiredSections) {  generateOrderSummary: function(data) {

    }      if (!data[section] || typeof data[section] !== "object") {    const { amounts } = data;

        return false;    return `

    return true;      }      <div class="order-summary">

  },    }        <h3>Order Summary</h3>

        <div class="summary-row">

  getOrCreateContainer(id) {    if (!Array.isArray(data.items) || data.items.length === 0) {          <span>Subtotal:</span>

    let container = document.getElementById(`modal-${id}`);      return false;          <span>₱${amounts.subtotal.toFixed(2)}</span>

    if (!container) {    }        </div>

      container = document.createElement("div");        ${amounts.discount ? `

      container.id = `modal-${id}`;    return true;        <div class="summary-row">

      container.className = "modal-section";  },          <span>Discount:</span>

      this.modal.querySelector(".modal-content").appendChild(container);          <span>-₱${amounts.discount.toFixed(2)}</span>

    }  getOrCreateContainer: function(id) {        </div>

    return container;    let container = document.getElementById(`modal-${id}`);        ` : ""}

  },    if (!container) {        <div class="summary-row">

      container = document.createElement("div");          <span>Delivery Fee:</span>

  // Content Generation      container.id = `modal-${id}`;          <span>₱${amounts.deliveryFee.toFixed(2)}</span>

  generateItemsList(items) {      container.className = "modal-section";        </div>

    return `      this.modal.querySelector(".modal-content").appendChild(container);        <div class="summary-row total">

      <div class="order-items">    }          <span>Total:</span>

        <h3>Order Items</h3>    return container;          <span>₱${amounts.total.toFixed(2)}</span>

        <ul class="items-list">  },        </div>

          ${items.map(item => `      </div>

            <li class="item">  // Content Generation    `;

              <span class="item-name">${item.name}</span>  generateItemsList: function(items) {  },

              <span class="item-quantity">x${item.quantity}</span>    return `

              <span class="item-price">₱${(item.price * item.quantity).toFixed(2)}</span>      <div class="order-items">  show: function() {

            </li>        <h3>Order Items</h3>    return new Promise((resolve, reject) => {

          `).join("")}        <ul class="items-list">      try {

        </ul>          ${items.map(item => `        if (!this.modal) {

      </div>            <li class="item">          throw new Error("Modal not initialized");

    `;              <span class="item-name">${item.name}</span>        }

  },              <span class="item-quantity">x${item.quantity}</span>

              <span class="item-price">₱${(item.price * item.quantity).toFixed(2)}</span>        this.modalPromiseResolve = resolve;

  generateCustomerInfo(customerInfo) {            </li>        this.modalPromiseReject = reject;

    return `          `).join("")}

      <div class="customer-info">        </ul>        this.modal.style.display = "block";

        <h3>Customer Information</h3>      </div>        setTimeout(() => {

        <p><strong>Name:</strong> ${customerInfo.name}</p>    `;          this.modal.classList.add("show");

        <p><strong>Phone:</strong> ${customerInfo.phone}</p>  },        }, 10);

        <p><strong>Email:</strong> ${customerInfo.email}</p>  generateCustomerInfo: function(customerInfo) {        const confirmBtn = this.modal.querySelector(".btn-confirm");

        <p><strong>Address:</strong> ${customerInfo.address}</p>    return `        const cancelBtn = this.modal.querySelector(".btn-cancel");

      </div>      <div class="customer-info">        const closeBtn = this.modal.querySelector(".modal-close");

    `;        <h3>Customer Information</h3>

  },        <p><strong>Name:</strong> ${customerInfo.name}</p>        if (confirmBtn) {

        <p><strong>Phone:</strong> ${customerInfo.phone}</p>          confirmBtn.onclick = () => {

  generatePaymentInfo(payment) {        <p><strong>Email:</strong> ${customerInfo.email}</p>            this.hide();

    return `        <p><strong>Address:</strong> ${customerInfo.address}</p>            resolve(true);

      <div class="payment-info">      </div>          };

        <h3>Payment Information</h3>    `;        }

        <p><strong>Method:</strong> ${payment.method}</p>        if (cancelBtn) {

        <p><strong>Status:</strong> <span class="payment-status ${payment.status.toLowerCase()}">${payment.status}</span></p>  generatePaymentInfo: function(payment) {          cancelBtn.onclick = () => {

        ${payment.reference ? `<p><strong>Reference:</strong> ${payment.reference}</p>` : ""}    return `            this.hide();

      </div>      <div class="payment-info">            resolve(false);

    `;        <h3>Payment Information</h3>          };

  },        <p><strong>Method:</strong> ${payment.method}</p>        }

        <p><strong>Status:</strong> <span class="payment-status ${payment.status.toLowerCase()}">${payment.status}</span></p>

  generateOrderSummary(data) {        ${payment.reference ? `<p><strong>Reference:</strong> ${payment.reference}</p>` : ""}        if (closeBtn) {

    const { amounts } = data;      </div>          closeBtn.onclick = () => {

    return `    `;            this.hide();

      <div class="order-summary">  },            resolve(false);

        <h3>Order Summary</h3>  generateOrderSummary: function(data) {        }

        <div class="summary-row">    const { amounts } = data;

          <span>Subtotal:</span>    return `      } catch (error) {

          <span>₱${amounts.subtotal.toFixed(2)}</span>      <div class="order-summary">        console.error("Error showing modal:", error);

        </div>        <h3>Order Summary</h3>        reject(error);

        ${amounts.discount ? `        <div class="summary-row">      }

        <div class="summary-row">          <span>Subtotal:</span>    });

          <span>Discount:</span>          <span>₱${amounts.subtotal.toFixed(2)}</span>  },

          <span>-₱${amounts.discount.toFixed(2)}</span>        </div>

        </div>        ${amounts.discount ? `  hide: function() {

        ` : ""}        <div class="summary-row">    if (!this.modal) return;

        <div class="summary-row">          <span>Discount:</span>

          <span>Delivery Fee:</span>          <span>-₱${amounts.discount.toFixed(2)}</span>    this.modal.classList.remove("show");

          <span>₱${amounts.deliveryFee.toFixed(2)}</span>        ` : ""}    const confirmBtn = this.modal.querySelector(".btn-confirm");

        </div>        <div class="summary-row">    const cancelBtn = this.modal.querySelector(".btn-cancel");

        <div class="summary-row total">          <span>Delivery Fee:</span>    const closeBtn = this.modal.querySelector(".modal-close");

          <span>Total:</span>          <span>₱${amounts.deliveryFee.toFixed(2)}</span>

          <span>₱${amounts.total.toFixed(2)}</span>        </div>    if (confirmBtn) confirmBtn.onclick = null;

        </div>        <div class="summary-row total">    if (cancelBtn) cancelBtn.onclick = null;

      </div>          <span>Total:</span>    if (closeBtn) closeBtn.onclick = null;

    `;          <span>₱${amounts.total.toFixed(2)}</span>

  },        </div>    setTimeout(() => {

      </div>      this.modal.style.display = "none";

  // Order Processing    `;    }, 300);

  processOrder() {    this.modalPromiseResolve = null;

    return new Promise(async (resolve, reject) => {  // Order Processing    this.modalPromiseReject = null;

      try {  processOrder: function() {  },

        const orderData = this.collectOrderData();    return new Promise(async (resolve, reject) => {

        if (!orderData) {      try {  processOrder: function() {

          throw new Error("Failed to collect order data");        const confirmed = await this.show();    return new Promise(async (resolve, reject) => {

        }        if (!confirmed) {      try {

          resolve({ success: false, message: "Order cancelled by user" });        const confirmed = await this.show();

        await this.updateModalContent(orderData);          return;        if (!confirmed) {

        const confirmed = await this.show();        }          resolve({ success: false, message: "Order cancelled by user" });

          return;

        if (!confirmed) {        const orderData = this.collectOrderData();        }

          resolve({ success: false, message: "Order cancelled by user" });        if (!orderData) {

          return;          throw new Error("Failed to collect order data");        const orderData = this.collectOrderData();

        }        }        if (!orderData) {

          throw new Error("Failed to collect order data");

        if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {        if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {        }

          throw new Error("WebSocket connection not available");          throw new Error("WebSocket connection not available");

        }        }        if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {

        const orderMessage = {        }

        const orderMessage = {          type: "new_order",

          type: "new_order",          data: orderData        const orderMessage = {

          data: orderData        };          type: "new_order",

        };          data: orderData

        this.socket.send(JSON.stringify(orderMessage));        };

        this.socket.send(JSON.stringify(orderMessage));        this.currentOrderPromise = { resolve, reject };

        this.currentOrderPromise = { resolve, reject };        this.socket.send(JSON.stringify(orderMessage));

        this.orderTimeout = setTimeout(() => {        this.currentOrderPromise = { resolve, reject };

        this.orderTimeout = setTimeout(() => {          if (this.currentOrderPromise) {

          if (this.currentOrderPromise) {            this.currentOrderPromise.reject(new Error("Order confirmation timeout"));        this.orderTimeout = setTimeout(() => {

            this.currentOrderPromise.reject(new Error("Order confirmation timeout"));            this.currentOrderPromise = null;          if (this.currentOrderPromise) {

            this.currentOrderPromise = null;          }            this.currentOrderPromise.reject(new Error("Order confirmation timeout"));

          }        }, 30000);            this.currentOrderPromise = null;

        }, 30000);          }

      } catch (error) {        }, 30000);

      } catch (error) {        console.error("Error processing order:", error);

        console.error("Error processing order:", error);        reject(error);      } catch (error) {

        reject(error);      }        console.error("Error processing order:", error);

      }    });        reject(error);

    });  collectOrderData: function() {  },

  },    try {

      const form = document.getElementById("orderForm");  collectOrderData: function() {

  collectOrderData() {      if (!form) {    try {

    try {        throw new Error("Order form not found");      const form = document.getElementById("orderForm");

      const form = document.getElementById("orderForm");      }      if (!form) {

      if (!form) {        throw new Error("Order form not found");

        throw new Error("Order form not found");      const cartItems = Array.from(document.querySelectorAll(".cart-item")).map(item => ({      }

      }        id: item.dataset.itemId,

        name: item.querySelector(".item-name").textContent,      const cartItems = Array.from(document.querySelectorAll(".cart-item")).map(item => ({

      const cartItems = Array.from(document.querySelectorAll(".cart-item")).map(item => ({        quantity: parseInt(item.querySelector(".item-quantity").value, 10),        id: item.dataset.itemId,

        id: item.dataset.itemId,        price: parseFloat(item.querySelector(".item-price").dataset.price)        name: item.querySelector(".item-name").textContent,

        name: item.querySelector(".item-name").textContent,      }));        quantity: parseInt(item.querySelector(".item-quantity").value, 10),

        quantity: parseInt(item.querySelector(".item-quantity").value, 10),        price: parseFloat(item.querySelector(".item-price").dataset.price)

        price: parseFloat(item.querySelector(".item-price").dataset.price)      if (cartItems.length === 0) {      }));

      }));        throw new Error("Cart is empty");

      }      if (cartItems.length === 0) {

      if (cartItems.length === 0) {      const subtotal = cartItems.reduce((sum, item) => sum + (item.price * item.quantity), 0);      }

        throw new Error("Cart is empty");      const deliveryFee = 50;

      }      const discount = 0;      const subtotal = cartItems.reduce((sum, item) => sum + (item.price * item.quantity), 0);

      const total = subtotal + deliveryFee - discount;      const deliveryFee = 50;

      const subtotal = cartItems.reduce((sum, item) => sum + (item.price * item.quantity), 0);      const discount = 0;

      const deliveryFee = 50;      const customerInfo = {      const total = subtotal + deliveryFee - discount;

      const discount = 0;        name: form.querySelector('[name="customer_name"]').value,

      const total = subtotal + deliveryFee - discount;        phone: form.querySelector('[name="phone"]').value,      const customerInfo = {

        email: form.querySelector('[name="email"]').value,        name: form.querySelector('[name="customer_name"]').value,

      const customerInfo = {        address: form.querySelector('[name="address"]').value        phone: form.querySelector('[name="phone"]').value,

        name: form.querySelector('[name="customer_name"]').value,      };        email: form.querySelector('[name="email"]').value,

        phone: form.querySelector('[name="phone"]').value,        address: form.querySelector('[name="address"]').value

        email: form.querySelector('[name="email"]').value,      const paymentMethod = form.querySelector('[name="payment_method"]:checked').value;      };

        address: form.querySelector('[name="address"]').value      return {      const paymentMethod = form.querySelector('[name="payment_method"]:checked').value;

      };        items: cartItems,

        customerInfo,      return {

      const paymentMethod = form.querySelector('[name="payment_method"]:checked').value;        payment: {        items: cartItems,

          method: paymentMethod,        customerInfo,

      return {          status: "Pending"        payment: {

        items: cartItems,        },          method: paymentMethod,

        customerInfo,        amounts: {          status: "Pending"

        payment: {          subtotal,        },

          method: paymentMethod,          deliveryFee,        amounts: {

          status: "Pending"          discount,          subtotal,

        },          total          deliveryFee,

        amounts: {        }          discount,

          subtotal,      };          total

          deliveryFee,    } catch (error) {        }

          discount,      console.error("Error collecting order data:", error);      };

          total      return null;    } catch (error) {

        }    }      console.error("Error collecting order data:", error);

      };  }      return null;

    } catch (error) {};    }

      console.error("Error collecting order data:", error);  }

      return null;// Initialize the modal handler};

    }document.addEventListener("DOMContentLoaded", () => {

  }  OrderConfirmationHandler.init();// Initialize the modal handler

};});document.addEventListener("DOMContentLoaded", () => {

  OrderConfirmationHandler.init();

// Initialize the handler});

document.addEventListener("DOMContentLoaded", () => {            itemsHtml += `

  OrderConfirmationHandler.init();              <div class="order-item">

});                <div class="item-details">
                  <span class="item-name">${item.name || ""}</span>
                  <span class="item-quantity">x${item.quantity || 0}</span>
                </div>
                <span class="item-price">₱${(
                  (item.price || 0) * (item.quantity || 0)
                ).toFixed(2)}</span>
              </div>
            `;
          });
        }
        orderItemsContainer.innerHTML = itemsHtml;
      // Update delivery details
      const elements = {
        customerName: document.getElementById("modalCustomerName"),
        customerPhone: document.getElementById("modalCustomerPhone"),
        deliveryAddress: document.getElementById("modalDeliveryAddress"),
        deliveryInstructions: document.getElementById(
          "modalDeliveryInstructions"
        ),
      };
      const customerInfo = data.customerInfo || {};
      if (elements.customerName) {
        elements.customerName.textContent =
          customerInfo.fullName || customerInfo.name || "";
      if (elements.customerPhone) {
        elements.customerPhone.textContent = customerInfo.phone || "";
      if (elements.deliveryAddress) {
        elements.deliveryAddress.textContent = customerInfo.address || "";
      if (elements.deliveryInstructions) {
        elements.deliveryInstructions.textContent =
          customerInfo.deliveryInstructions || "No special instructions";
      // Update payment summary
      const paymentElements = {
        subtotal: document.getElementById("modalSubtotal"),
        deliveryFee: document.getElementById("modalDeliveryFee"),
        discounts: document.getElementById("modalDiscounts"),
        total: document.getElementById("modalTotalAmount"),
        discountRow: document.getElementById("modalDiscountRow"),
      const amounts = data.amounts || {};
      if (paymentElements.subtotal && typeof amounts.subtotal === "number") {
        paymentElements.subtotal.textContent = amounts.subtotal.toFixed(2);
      if (
        paymentElements.deliveryFee &&
        typeof amounts.deliveryFee === "number"
      ) {
        paymentElements.deliveryFee.textContent =
          amounts.deliveryFee.toFixed(2);
      if (paymentElements.discountRow && paymentElements.discounts) {
        if (
          typeof amounts.totalDiscount === "number" &&
          amounts.totalDiscount > 0
        ) {
          paymentElements.discounts.textContent =
            amounts.totalDiscount.toFixed(2);
          paymentElements.discountRow.style.display = "flex";
        } else {
          paymentElements.discountRow.style.display = "none";
      if (paymentElements.total && typeof amounts.total === "number") {
        paymentElements.total.textContent = amounts.total.toFixed(2);
      console.error("Error updating modal content:", error);
      throw error;
    }
  async processOrder() {
    const confirmBtn = this.modal.querySelector(".btn-confirm");
    if (confirmBtn) {
      confirmBtn.disabled = true;
      confirmBtn.innerHTML =
        '<i class="fas fa-spinner fa-spin"></i> Processing...';
      const checkoutForm = document.getElementById("checkoutForm");
      if (!checkoutForm) {
        throw new Error("Checkout form not found");
      const formData = new FormData(checkoutForm);
      const orderData = Object.fromEntries(formData.entries());
      // Add cart items
      orderData.items = cartManager.items;
      // Send order to server
      const response = await fetch("process_order.php", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "X-CSRF-Token": document.querySelector('meta[name="csrf-token"]')
            ?.content,
        },
        body: JSON.stringify(orderData),
      });
      const data = await response.json();
      if (data.success) {
        notificationManager.show(data.message, NotificationType.SUCCESS);
        cartManager.clearCart();
        // Emit WebSocket event to crew dashboard after order placement
        const orderEvent = {
          order: {
            order_id: data.orderId,
            order_number: data.orderNumber,
            items: orderData.items,
            total_amount: orderData.amounts
              ? orderData.amounts.total
              : undefined,
            delivery_instructions: orderData.customerInfo
              ? orderData.customerInfo.deliveryInstructions
            payment_method: orderData.payment
              ? orderData.payment.method
            created_at: data.status
              ? data.status.timestamp
              : new Date().toISOString(),
          },
        };
        // Only send if socket is ready, otherwise queue
        const eventString = JSON.stringify(orderEvent);
          this.socket &&
          this.socketReady &&
          this.socket.readyState === WebSocket.OPEN
          this.socket.send(eventString);
        } else if (this.socket) {
          if (!this.socketQueue) this.socketQueue = [];
          this.socketQueue.push(eventString);
        // Redirect to confirmation page
        if (data.routing && data.routing.redirectUrl) {
          setTimeout(() => {
            window.location.href = data.routing.redirectUrl;
          }, 1500);
        throw new Error(data.message || "Failed to process order");
      notificationManager.show(error.message, NotificationType.ERROR);
      // Re-enable button
      if (confirmBtn) {
        confirmBtn.disabled = false;
        confirmBtn.innerHTML = '<i class="fas fa-check"></i> Place Order';
  initWebSocket: function() {
    const wsProtocol = window.location.protocol === "https:" ? "wss:" : "ws:";
    const wsHost = window.location.hostname;
    const wsPort = "8080";
    const wsUrl = `${wsProtocol}//${wsHost}:${wsPort}/ws`;
      this.socket = new WebSocket(wsUrl);
      this.socket.onopen = () => {
        console.log("WebSocket connection established");
        // Register as customer
        this.socket.send(
          JSON.stringify({
            action: "authenticate",
            userType: "customer",
            userId: document.getElementById("userId").value,
          })
        );
      this.socket.onmessage = (event) => {
        const data = JSON.parse(event.data);
        this.handleWebSocketMessage(data);
      this.socket.onerror = (error) => {
        console.error("WebSocket error:", error);
      this.socket.onclose = () => {
        console.log("WebSocket connection closed");
        // Try to reconnect after 5 seconds
        setTimeout(() => this.initWebSocket(), 5000);
      console.error("Failed to initialize WebSocket:", error);
  handleWebSocketMessage: function(data) {
    switch (data.type) {
      case "order_status":
        this.handleOrderStatusUpdate(data);
        break;
      case "order_confirmation":
        this.handleOrderConfirmation(data);
  handleOrderStatusUpdate: function(data) {
    notificationManager.show(
      `Order #${data.orderNumber} status: ${data.status}`,
      NotificationType.INFO
    );
  handleOrderConfirmation: function(data) {
      `Order #${data.orderNumber} has been confirmed! Estimated delivery time: ${data.estimatedTime}`,
      NotificationType.SUCCESS
};
// Initialize handler
OrderConfirmationHandler.init();
